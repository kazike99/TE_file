console.log(entityName)

let $injector = widgetContext.$scope.$injector;
let customDialog = $injector.get(widgetContext.servicesMap.get('customDialog'));
let deviceService = $injector.get(widgetContext.servicesMap.get('deviceService'));
let attributeService = $injector.get(widgetContext.servicesMap.get('attributeService'));
let token = localStorage.getItem('jwt_token')
// let dashboardid = widgetContext.dashboardService
//         .currentUrl.replace(/\/.+\//g, "")
let headers = {
                'content-Type': 'application/json',
     "X-Authorization": "Bearer " + token
      }
// var loadingGif = document.getElementById('loadingGif');
// loadingGif.style.display = 'block'; // 显示加载动画
var contentDiv = document.getElementById('table-container');
var imgid = document.getElementById('loadingGif');
let id = entityId.id  
var dataid = widgetContext.datasources
var list1 = []
async function fetchData() {
for (let i of dataid){
 const response = getfunction("https://thingseye.io/api/relations/info?toId="+i.entityId+"&toType=DEVICE",headers)
 const data = await response
 list1.push(data)
}
return list1
}
fetchData().then(data=>{
    let listdata3 = []
    for (let i=0;i<data.length;i++){
        //listdata3.push(dataid[i].name)
        var obj = {}
        for(let i2 of data[i]){
            let type = i2.from.entityType
            if (type !=="INTEGRATION"){
                let devid = i2.from.id
                let name = i2.fromName
                obj[name] = devid
            }
        }
        listdata3.push(obj)
    }
    //console.log(listdata3)
    const listdata4 = {}
    for (let i=0;i<listdata3.length;i++){
        listdata4[dataid[i].name]=listdata3[i]
    }
    //console.log(listdata4)
    const listdata5 = []
    for (let key in listdata4){
        //console.log(listdata4[key])
        if (Object.keys(listdata4[key]).length !==0){
        listdata5.push(listdata4[key])
        }
    }
    const apiUrls = []
    for (let a in listdata4){
        for (let a1 in listdata4[a]){
            
        apiUrls.push("https://thingseye.io/api/plugins/telemetry/DEVICE/"+listdata4[a][a1]+"/values/timeseries?useStrictDataTypes=false")
            
        }
    }
    // 创建一个数组来存储URL
const urlsToFetch = apiUrls.map(url => url); // 这里只是简单地复制了apiUrls数组，但你也可以进行其他处理

Promise.all(
  urlsToFetch.map((url, index) => {
    // 对每个URL发送fetch请求，并返回一个promise
    return fetch(url, {
      method: 'GET', // 或者 'POST'，根据你的API要求来设置
      headers: headers, // 将headers对象传递给请求
      // 如果需要发送请求体，可以在这里添加 body: JSON.stringify({...})
    })
    .then(response => {
      // 检查响应状态是否正常（状态码在200-299之间）
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
      // 返回响应的JSON数据
      return response.json();
    })
    .catch(error => {
      // 处理fetch请求中的错误
      console.error('There was a problem with the fetch operation:', error);
      // 可以选择返回一个默认值或重新抛出错误
      throw error;
    });
  })
)
.then(results => {
  // 所有fetch请求都成功完成时，处理结果数组
  //console.log('All fetch requests completed successfully:', results);
  
  // 使用原始的URL数组和结果数组来创建objlist
  let objlist = urlsToFetch.map((url, index) => {
    const regex = /DEVICE\/([^/]*)\/values/;
    const match = url.match(regex); // 现在在原始的URL上调用match方法
    if (match) {
      const extractedString = match[1];
      let obj1 = {};
      obj1[extractedString] = results[index]; // 使用对应的结果
      return obj1;
    } else {
      // 如果没有匹配到URL，可以返回一个空对象或其他默认值
      return {};
    }
  });
  //console.log(objlist)
  function getKey(obj) {
  // 使用 Object.keys() 获取对象的所有键
  // 由于我们假设每个对象都只有一个键，所以直接返回第一个键
  return Object.keys(obj)[0];
}
  const entries = objlist.map(item => [getKey(item), Object.values(item)[0]]);

    // 使用 Object.fromEntries() 方法将键值对数组转换为对象
    const object = Object.fromEntries(entries);
    
    // 输出转换后的对象
    //console.log(object);
    const allurls = []
    for (let i in object){
        allurls.push("https://thingseye.io/api/device/info/"+i)
    }
    const fetchPromises = allurls.map(url => {
    return fetch(url, {
      method: 'GET', // 或者 'POST'，根据你的API要求来设置
      headers: headers})
    .then(response => {
      // 检查响应状态是否正常
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      // 返回响应的JSON数据
      return response.json();
    })
    .catch(error => {
      // 处理fetch请求中的错误
      console.error('Fetch error:', error);
      // 可以在这里返回一个默认值或重新抛出错误
      return null; // 或者 throw error;
    });
});

// 使用Promise.all方法处理所有的fetch promises
Promise.all(fetchPromises)
  .then(results => {
    // 所有fetch请求都成功完成，results是一个包含所有响应数据的数组
    //console.log('All fetch requests completed:', results);
    let alldata = {}
    for (let i of results){
        let id = i.id.id
        let name = i.name
        let type = i.type
        let flg = i.active
        let data = object[id]
        alldata[name] = {id:id,name:name,type:type,flg:flg,data:data}
    }
    //console.log(alldata)
    //console.log(listdata4)
    let newalldata = {} 
    for (let q in listdata4){
        let listobj = {}
        for (let w in alldata){
            if(w.includes(q)){
                const splitArray = w.split(":");
                const resultString = splitArray[1];
                listobj[resultString] = alldata[w]
            }
        newalldata[q] = listobj    
        }
    }
    console.log(newalldata)
    const obj = newalldata
    const deviceIdInfo = {};
    // 初始化一个空对象来存储键及其出现次数和相关信息
        // 初始化一个空对象来存储设备ID及其出现的次数和相关信息
     const keyInfo = {};
     // 遍历外部对象的每个键值对（deuiKey）
for (const deuiKey in obj) {
  const innerObj = obj[deuiKey];

  // 遍历内部对象的每个子对象（这里假设子对象的键就是我们要找的设备ID，如'01b10b27686'）
  for (const deviceId in innerObj) {
    // 检查这个设备ID是否已经在deviceIdInfo中记录过
    if (deviceIdInfo.hasOwnProperty(deviceId)) {
      // 如果已经记录过，则将该deuiKey添加到该设备ID的deuiKeys数组中（如果不存在的话）
      if (!deviceIdInfo[deviceId].deuiKeys.includes(deuiKey)) {
        deviceIdInfo[deviceId].deuiKeys.push(deuiKey);
      }
      // 并且添加一个包含所需字段的新对象到该设备ID的deviceDatas数组中
      const rssiData = innerObj[deviceId].data.RSSI ? [innerObj[deviceId].data.RSSI[0]] : [];
      deviceIdInfo[deviceId].deviceDatas.push({
        deuiKey: deuiKey,
        deviceData: {
          flg: innerObj[deviceId].flg,
          id: innerObj[deviceId].id, // 保留id字段
          type: innerObj[deviceId].type,
          RSSI: rssiData
        }
      });
    } else {
      // 如果还没有记录过，则初始化其信息
      deviceIdInfo[deviceId] = {
        deuiKeys: [deuiKey], // 存储该设备ID出现的所有deuiKey
        deviceDatas: [ // 存储该设备ID下的所有简化后的设备信息
          {
            deuiKey: deuiKey,
            deviceData: {
              flg: innerObj[deviceId].flg,
              id: innerObj[deviceId].id, // 保留id字段
              type: innerObj[deviceId].type,
              RSSI: innerObj[deviceId].data.RSSI ? [innerObj[deviceId].data.RSSI[0]] : []
            }
          }
        ]
      };
    }
  }
}

// 构建结果对象
const result = {};
// 遍历所有设备ID的信息
for (const deviceId in deviceIdInfo) {
  // 检查该设备ID是否出现在多个deuiKey下（即出现次数超过1次）
  if (deviceIdInfo[deviceId].deuiKeys.length > 1) {
    // 直接使用设备ID作为结果的键
    if (!result.hasOwnProperty(deviceId)) {
      result[deviceId] = [];
    }

    // 遍历该设备ID下的所有设备信息，并添加到结果对象中
    deviceIdInfo[deviceId].deviceDatas.forEach(deviceData => {
      const { deuiKey, deviceData: data } = deviceData;
      // 构建每个deuiKey下的设备信息对象，并添加到结果数组中
      // 注意：这里我们保留所需的字段，包括id
      const resultObj = { [deuiKey]: { ...data } };
      result[deviceId].push(resultObj);
    });
  }
}

// 输出结果
//console.log(JSON.stringify(result, null, 2));   
  const result1 = {};
  const obj1 = result
for (const key in obj1) {
  if (obj1.hasOwnProperty(key)) {
    let maxRssiValue = -Infinity;
    let maxRssiValueNum = -Infinity; // 用于存储数字形式的maxRssiValue
    let maxRssiTs = -Infinity;
    let maxObj = null;

    for (const item of obj1[key]) {
      for (const deuiKey in item) {
        if (item.hasOwnProperty(deuiKey)) {
          const rssi = item[deuiKey].RSSI;
          if (rssi && rssi.length > 0) {
            for (const entry of rssi) {
              // 将RSSI的value从字符串转换为数字
              const rssiValueNum = Number(entry.value);
              if (!isNaN(rssiValueNum)) { // 检查转换是否成功
                if (rssiValueNum > maxRssiValueNum) {
                  maxRssiValueNum = rssiValueNum;
                  maxRssiValue = entry.value; // 保留字符串形式的value
                  maxRssiTs = entry.ts;
                  maxObj = { deuiKey, entry, item: item[deuiKey] }; // 存储整个对象以便后续获取flg、id和type
                } else if (rssiValueNum === maxRssiValueNum && entry.ts > maxRssiTs) {
                  maxRssiTs = entry.ts;
                  maxObj = { deuiKey, entry, item: item[deuiKey] };
                }
              }
            }
          }
        }
      }
    }

    // 如果找到了有效的最大RSSI值，则将其添加到结果中
    if (maxObj !== null) {
      result1[key] = {
        deuiKey: maxObj.deuiKey,
        maxRssiValue: maxObj.entry.value, // 保留字符串形式的RSSI值
        maxRssiTs: maxObj.entry.ts,
        flg: maxObj.item.flg,
        id: maxObj.item.id,
        type: maxObj.item.type
      };
    }
  }
}
//console.log(JSON.stringify(result1, null, 2));
const specificDeuiKey = entityName;
const filteredObj = {};

for (const key in result1) {
  if (result.hasOwnProperty(key)) {
    const item = result1[key];
    if (item.deuiKey === specificDeuiKey) {
      filteredObj[key] = item;
    }
  }
}
//console.log("整理后的")
console.log(JSON.stringify(filteredObj, null, 2));
    const flgdata = {}
   for (let i in filteredObj) {
         const name = filteredObj[i]["deuiKey"]+":"+i
         const type = filteredObj[i]["type"]
         const time = filteredObj[i]["maxRssiTs"]
         const RSSI = filteredObj[i]["maxRssiValue"]
         const id1 = filteredObj[i]["id"]
         const flg = filteredObj[i]["flg"]
         const tableBody = document.getElementById('table-body');
         flgdata[name] = id1
        const row = document.createElement('tr');
        
        // 创建第一个单元格，并添加一个按钮
        const firstCell = document.createElement('td');
        const button = document.createElement('button');
        button.textContent = `${name}`;
        // 你可以在这里为按钮添加点击事件处理函数
        button.addEventListener('click', (event) => {
            // 使用event.target获取触发事件的元素
            const clickedButton = event.target;
            // 读取按钮的textContent属性来获取按钮的文本
            const buttonText = clickedButton.textContent;

            // 获取浮动窗口和打开按钮的DOM元素
            var floatingWindow = document.getElementById("floatingWindow");
            //var btn = document.getElementById("openWindowBtn");
            var span = document.getElementsByClassName("close")[0];
            const modalMessage = document.getElementById("modalMessage");
            modalMessage.textContent = flgdata[buttonText]
            // 打开浮动窗口
             floatingWindow.style.display = "block";

            // 点击 <span> (x)，关闭浮动窗口
            span.onclick = function() {
              floatingWindow.style.display = "none";
            }
            
            // 当用户点击浮动窗口外部时，关闭浮动窗口（可选）
            window.onclick = function(event) {
              if (event.target == floatingWindow) {
                floatingWindow.style.display = "none";
              }
            }
            
            // 防止当用户点击关闭按钮时，事件冒泡到浮动窗口并关闭它（可选）
            span.onclick = function(event) {
              event.stopPropagation();
              floatingWindow.style.display = "none";
            }
        });
        firstCell.appendChild(button);

        // 创建第二个单元格，并填充数据
        const secondCell = document.createElement('td');
        secondCell.textContent = `${type}`;
        const Cell2 = document.createElement('td');
        Cell2.textContent = `${RSSI}`;
         const Cell3 = document.createElement('td');
        Cell3.textContent = `${flg}`; 
         const Cell4 = document.createElement('td');
        Cell4.textContent = `${id1}`; 
         const Cell5 = document.createElement('td');
        Cell5.textContent = `${time}`; 
        // 将单元格添加到行中
        row.appendChild(firstCell);
        row.appendChild(secondCell);
        row.appendChild(Cell2);
        row.appendChild(Cell3);
        row.appendChild(Cell4);
        row.appendChild(Cell5);

        // 将行添加到表格体中
        tableBody.appendChild(row);
   }
   if (!imgid || !contentDiv) {
        console.error('One or both elements not found!');
        return; // 如果元素不存在，则退出函数
    }
   imgid.style.display = 'none'; // 隐藏加载动画
   contentDiv.style.display = 'block'; // 恢复初始内容可见性
   // 检查元素是否存在
  })
  .catch(error => {
    console.error('Promise.all error:', error);
  });
})
.catch(error => {
  // 如果任何一个fetch请求失败，处理错误
  console.error('One or more fetch requests failed:', error);
});
                
})

openAddDeviceDialog();
function openAddDeviceDialog() {
    customDialog.customDialog(htmlTemplate, AddDeviceDialogController).subscribe();
}
function AddDeviceDialogController(instance) {
    let vm = instance;

    vm.cancel = function() {
        vm.dialogRef.close(null);
    };
}
async function getfunction(url,headers){
    let get = await fetch(url,{
       method: 'GET', // 或者其他HTTP方法
       headers: headers
      // body: JSON.stringify(data)
    })
    if (get.ok){
        //console.log("成功")
    return get.json() 
    }
    else{
        console.log("失败",get.status)
    }
 }
